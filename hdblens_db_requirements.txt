HDBLens Data Requirements — Relational & Non‑Relational (Finalized Reference)


============================================================
A) RELATIONAL DATABASE (PostgreSQL, BCNF)
============================================================

Purpose
- System of record (SoR) for official HDB resale data.
- Strict normalization (BCNF), lossless decompositions, enforced referential integrity.
- Supports analytical joins and canonical views (e.g., remaining lease).

Entities (final names)
1) Towns
   - Columns:
     - town_id BIGSERIAL PRIMARY KEY
     - town_name TEXT NOT NULL UNIQUE
   - Notes: Surrogate key; town_name is natural key (unique).

2) Flats   (represents block-level address; NOT individual apartment units)
   - Columns:
     - flat_id SERIAL PRIMARY KEY
     - town_id INTEGER NOT NULL REFERENCES Towns(town_id) ON UPDATE CASCADE ON DELETE RESTRICT
     - street_name TEXT NOT NULL
     - block_no TEXT NOT NULL
     - lease_start_year INTEGER NOT NULL
     - UNIQUE (town_id, street_name, block_no)    -- natural address key
   - Notes: One lease_start_year per flat (block).

3) StoreyRange
   - Columns:
     - storey_range_id SERIAL PRIMARY KEY
     - storey_range TEXT NOT NULL UNIQUE           -- e.g., '01 TO 03', '04 TO 06'

4) FlatModel
   - Columns:
     - flat_model_id SERIAL PRIMARY KEY
     - flat_model TEXT NOT NULL UNIQUE             -- e.g., 'New Generation', 'Improved'

5) Transactions
   - Columns:
     - txn_id BIGSERIAL PRIMARY KEY
     - txn_month DATE NOT NULL                     -- canonical month (use 1st of month)
     - txn_price NUMERIC(12,2) NOT NULL
     - floor_area_sqm NUMERIC(8,2) NOT NULL        -- unit-level attribute; kept in Transaction
     - flat_type TEXT NOT NULL                     -- e.g., '3 ROOM' (kept as TEXT)
     - flat_model_id INTEGER NOT NULL REFERENCES FlatModel(flat_model_id) ON UPDATE CASCADE ON DELETE RESTRICT
     - storey_range_id INTEGER NOT NULL REFERENCES StoreyRange(storey_range_id) ON UPDATE CASCADE ON DELETE RESTRICT
     - flat_id INTEGER NOT NULL REFERENCES Flats(flat_id) ON UPDATE CASCADE ON DELETE RESTRICT
   - Optional de-dup guard:
     - dedup_key BYTEA GENERATED ALWAYS AS (sha256 over txn fields) STORED
     - UNIQUE (dedup_key)

Derived Views
- Transactions_WithRemainingLease:
  remaining_lease_months_calc = f(Flats.lease_start_year, Transactions.txn_month), assuming 99‑year original lease.
  (Do not store remaining lease as a base column; it varies by reference date.)

Integrity & Constraints
- All foreign keys are NOT NULL; parent deletes are RESTRICTed.
- CHECKs (recommended):
  - Transactions.txn_price > 0
  - Transactions.floor_area_sqm > 0
  - date_trunc('month', txn_month) = txn_month
- Indexes (recommended):
  - Transactions(txn_month), Transactions(flat_id), Transactions(flat_model_id), Transactions(storey_range_id)

Relationship Cardinalities
- Towns (1) —— (N) Flats
- Flats (1) —— (N) Transactions
- StoreyRange (1) —— (N) Transactions
- FlatModel (1) —— (N) Transactions

Relationship Names (suggested labels for ERD)
- Towns —has→ Flats  /  Flats —located in→ Towns
- Flats —records→ Transactions  /  Transactions —pertains to→ Flats
- StoreyRange —classifies→ Transactions  /  Transactions —is classified by→ StoreyRange
- FlatModel —categorizes→ Transactions  /  Transactions —is of type→ FlatModel

ETL Requirements (from CSV)
1) Stage into table staging_hdb(month, town, flat_type, block, street_name, storey_range, floor_area_sqm, flat_model, lease_commence_date, remaining_lease, resale_price).
2) Seed lookups:
   - Towns(town_name) from distinct town
   - StoreyRange(storey_range) from distinct storey_range
   - FlatModel(flat_model) from distinct flat_model
3) Build Flats using distinct (town, street_name, block) + lease_commence_date → lease_start_year.
4) Insert Transactions by joining lookups; compute txn_month = TO_DATE(month, 'YYYY‑MM').
5) Optional: enable dedup_key on Transactions to prevent double loads.


============================================================
B) NON‑RELATIONAL DATABASE (MongoDB) — Reviews & Analytics
============================================================

Purpose
- Provide a bare‑minimum reviews feature to demonstrate full CRUD.
- No user accounts; each review includes a nickname, star rating (1–5), text (≤200 chars), and timestamps.

Collection
1) reviews
   Fields:
     - _id: ObjectId (MongoDB primary key)
     - nickname: string, required, 1..30 chars
     - rating: int, required, 1..5 (star rating)
     - text: string, required, 1..200 chars
     - created_at: date (ISODate), required
     - updated_at: date (ISODate), optional (set on edits)
   Validation (JSON Schema):
     - Enforce types and length constraints above.
     - additionalProperties: false
   Indexes:
     - { created_at: -1 }  // latest-first lists
     - { rating: -1 }      // filter/sort by stars
   Notes:
     - No users collection; nickname is free text.
     - If later needed, add 'status' (published|removed) for soft deletes and moderation.

CRUD Requirements (example semantics)
- CREATE  (POST /reviews)
  Request: { nickname, rating, text }
  Server:
    - Validate rating in [1..5], lengths, and non-empty text
    - Insert document with created_at=now, updated_at=now
  Response: inserted document (_id)

- READ (GET /reviews?sort=recent|top&min_rating=&limit=&skip=)
  Query:
    - Filter by min_rating if provided (rating >= min_rating)
    - Sort recent: {created_at:-1}; top: {rating:-1, created_at:-1}
    - Paginate with limit/skip
  Response: list of reviews

- UPDATE (PATCH /reviews/{id})
  Request: partial { nickname?, rating?, text? }
  Server:
    - Validate fields if present (1..5 for rating; length caps)
    - Set updated_at=now
  Response: updated document or 204

- DELETE (DELETE /reviews/{id})
  Server:
    - Hard delete for demo (dbh.reviews.deleteOne({_id}))
    - Optional: switch to soft delete by adding 'status' and filtering reads


============================================================
C) NAMING CONVENTIONS & NOTES
============================================================
- Snake_case for SQL column names; lowerCamelCase for Mongo field names is acceptable but be consistent.
- Time fields use DATE (SQL) or ISODate (Mongo). Store UTC; format in UI.
- Avoid storing derived fields as base columns; expose via views (SQL) or compute in read model (Mongo).
- Keep TEXT enumerations small or promote to lookup collections/tables when stability matters (e.g., FlatModel).

End of document.
